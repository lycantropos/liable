#!/usr/bin/env python3
import collections
import inspect
import operator
import os
from collections import defaultdict
from functools import partial
from itertools import (filterfalse,
                       chain)
from types import FunctionType
from typing import (Any,
                    Optional,
                    Type,
                    Callable,
                    Iterator,
                    Iterable,
                    Dict,
                    Tuple,
                    List)

import autopep8
import click
from pathspec import (PathSpec,
                      patterns)

from liable import (modules,
                    namespaces,
                    annotator,
                    files,
                    catalog,
                    functions,
                    strings)
from liable.utils import is_python_module
from liable.validators import (validate_paths,
                               validate_modules_paths)


@click.group()
def main() -> None:
    return


@main.command(name='modules')
@click.option('--recursive', '-r',
              is_flag=True,
              help='Recursively walks through given directory.')
@click.option('--ignore-patterns-path', '-i',
              help='Path to file with patterns of paths names to ignore '
                   '(based on ".gitignore" syntax, '
                   'more at https://git-scm.com/docs/gitignore).')
@click.argument('paths',
                nargs=-1)
def search_modules(recursive: bool,
                   ignore_patterns_path: str,
                   paths: List[str]) -> None:
    """Searches Python modules in paths."""
    if not paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    paths = list(map(os.path.abspath, paths))

    try:
        validate_paths(paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    files_seeker = partial(files.find,
                           recursive=recursive)
    files_paths = chain.from_iterable(map(files_seeker, paths))
    modules_paths = filter(is_python_module, files_paths)

    if ignore_patterns_path:
        with open(ignore_patterns_path) as ignore_patterns_file:
            path_spec = PathSpec.from_lines(patterns.GitWildMatchPattern,
                                            ignore_patterns_file)
        modules_paths = list(modules_paths)
        ignored_paths = list(path_spec.match_files(modules_paths))
        modules_paths = filterfalse(partial(operator.contains,
                                            ignored_paths),
                                    modules_paths)

    for module_path in modules_paths:
        click.echo(module_path)


CoderType = Callable[[FunctionType, str, namespaces.NamespaceType], str]

TEST_CASE_PARAMETER_TEMPLATE = '{parameter}: {annotation}'
TEST_CASE_DEFINITION_TEMPLATE = 'def test_{function}({parameters}) -> None:\n'
RESULT_NAME = 'result'
FUNCTION_ARGUMENTS_TEMPLATES = {
    inspect._POSITIONAL_ONLY: '{argument}',
    inspect._POSITIONAL_OR_KEYWORD: '{argument}',
    inspect._VAR_POSITIONAL: '*{argument}',
    inspect._KEYWORD_ONLY: '{parameter}={argument}',
    inspect._VAR_KEYWORD: '**{argument}'
}
FUNCTION_CALL_TEMPLATE = '{result} = {function}({arguments})\n\n'
RETURN_TYPE_CHECK_TEMPLATE = 'isinstance({result}, {return_type})'
NONE_RETURN_TYPE_CHECK_TEMPLATE = '{result} is None'
ASSERTION_TEMPLATE = 'assert {statement}\n'


@main.command(name='tests')
@click.option('--spaces-count', '-s',
              type=click.IntRange(1),
              default=4,
              help='Number of spaces used for indentation.')
@click.argument('modules_paths',
                nargs=-1)
def generate_tests(spaces_count: int,
                   modules_paths: List[str]) -> None:
    """Generates test cases skeletons for modules."""
    if not modules_paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    modules_paths = list(map(os.path.abspath, modules_paths))

    try:
        validate_paths(modules_paths)
        validate_modules_paths(modules_paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    built_ins = namespaces.built_ins()
    test_cases_generator = partial(generate_module_tests_code,
                                   built_ins=built_ins,
                                   spaces_count=spaces_count,
                                   coder=generate_test_case,
                                   generic_return_type=False)
    for module_path in modules_paths:
        try:
            test_cases = test_cases_generator(module_path)
        except ImportError as err:
            raise click.BadParameter(err) from err

        click.echo(test_cases)


def generate_module_tests_code(module_path: str,
                               *,
                               built_ins: namespaces.NamespaceType,
                               spaces_count: int,
                               coder: CoderType,
                               generic_return_type: bool) -> str:
    module = modules.from_path(module_path)

    namespace = namespaces.from_module(module)
    namespace.update(built_ins)

    if collections not in namespace.values():
        namespace[collections.__name__] = collections
    if Any not in namespace.values():
        namespace['Any'] = Any
    if Optional not in namespace.values():
        namespace['Optional'] = Optional

    module_objects = [content
                      for content in namespace.values()
                      if modules.is_object_from_module(content,
                                                       module=module)]
    module_functions = [object_
                        for object_ in module_objects
                        if inspect.isfunction(object_)]

    dependent_objects = namespaces.dependent_objects(module)
    dependent_objects.update(built_ins)
    dependencies_detector = partial(functions.dependencies,
                                    generic_return_type=generic_return_type)
    signatures_dependants = chain.from_iterable(map(dependencies_detector,
                                                    module_functions))
    object_path_seeker = partial(search_object_path,
                                 namespace=namespace,
                                 dependent_objects=dependent_objects)
    dependants_paths = set(chain(map(object_path_seeker,
                                     signatures_dependants)))

    def is_built_in_path(object_path: catalog.ObjectPath) -> bool:
        return object_path in built_ins

    dependants_paths = filterfalse(is_built_in_path, dependants_paths)
    dependants_paths = objects_paths_by_modules_names(dependants_paths)

    imports = to_imports(dependants_paths)

    tab = ' ' * spaces_count
    coder = partial(coder,
                    tab=tab,
                    namespace=namespace)
    code_blocks = map(coder, module_functions)
    return autopep8.fix_code(''.join(chain(imports, code_blocks)),
                             options={'aggressive': True,
                                      'max_line_length': 79})


def to_imports(dependants_paths: Dict[str, List[catalog.ObjectPath]]
               ) -> Iterator[str]:
    def is_path_relative(object_path: catalog.ObjectPath) -> bool:
        return object_path.relative

    for module_name, paths in dependants_paths.items():
        relative_paths = list(filter(is_path_relative, paths))
        if relative_paths:
            objects_names = list(map(operator.attrgetter('object'),
                                     relative_paths))
            objects_names_str = strings.join_with_wrapping(objects_names)
            yield ('from {module} import {objects}\n'
                   .format(module=module_name,
                           objects=objects_names_str))
        absolute_path = next(filterfalse(is_path_relative, paths), None)
        if absolute_path is not None:
            yield 'import {module}\n'.format(module=module_name)


def objects_paths_by_modules_names(objects_paths: Iterable[catalog.ObjectPath]
                                   ) -> Dict[str, List[catalog.ObjectPath]]:
    result = defaultdict(list)
    for object_path in objects_paths:
        result[object_path.module].append(object_path)
    return result


def search_object_path(object_,
                       *,
                       namespace: namespaces.NamespaceType,
                       dependent_objects: namespaces.NamespaceType
                       ) -> catalog.ObjectPath:
    try:
        return namespaces.search_path(object_,
                                      namespace=namespace)
    except LookupError:
        return namespaces.search_path(object_,
                                      namespace=dependent_objects)


def generate_test_case(function: FunctionType,
                       *,
                       tab: str,
                       namespace: namespaces.NamespaceType) -> str:
    signature = inspect.signature(function)
    function_parameters = signature.parameters.values()

    def to_name(annotation: Type) -> str:
        annotation = annotator.normalize(annotation)
        return annotation.to_string(namespace)

    test_parameters_str = strings.join(
            TEST_CASE_PARAMETER_TEMPLATE.format(
                    parameter=parameter.name,
                    annotation=to_name(parameter.annotation)
            )
            for parameter in function_parameters)
    function_arguments_str = strings.join(
            FUNCTION_ARGUMENTS_TEMPLATES[parameter.kind].format(
                    parameter=parameter.name,
                    argument=parameter.name)
            for parameter in function_parameters)
    return_annotation = signature.return_annotation
    return_annotation_bases = to_bases(return_annotation)

    def to_statement(annotation_base: Type) -> str:
        if annotation_base is None:
            return NONE_RETURN_TYPE_CHECK_TEMPLATE
        else:
            return RETURN_TYPE_CHECK_TEMPLATE

    statements = sorted(set(map(to_statement, return_annotation_bases)))
    statement = strings.join_with_wrapping(statements,
                                           sep='\nor\n')
    assertion_template = ASSERTION_TEMPLATE.format(statement=statement)

    return_type = None
    defined_return_annotation_bases = list(filter(None,
                                                  return_annotation_bases))
    if defined_return_annotation_bases:
        if len(defined_return_annotation_bases) == 1:
            return_annotation_base, = defined_return_annotation_bases
            return_type = to_name(return_annotation_base)
        else:
            return_types = list(map(to_name,
                                    defined_return_annotation_bases))
            return_types_str = ', '.join(return_types)
            return_type = ('({return_types})'
                           .format(return_types=return_types_str))

    test_case_template = (TEST_CASE_DEFINITION_TEMPLATE
                          + tab + FUNCTION_CALL_TEMPLATE
                          + tab + assertion_template)
    return test_case_template.format(function=function.__name__,
                                     parameters=test_parameters_str,
                                     result=RESULT_NAME,
                                     arguments=function_arguments_str,
                                     return_type=return_type)


def to_bases(annotation: Type) -> Tuple[Type, ...]:
    if not isinstance(annotation, annotator.Annotation):
        annotation = annotator.normalize(annotation)
    return annotation.bases


if __name__ == '__main__':
    main()
