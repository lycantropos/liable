#!/usr/bin/env python3
import ast
import collections
import inspect
import operator
import os
import sys
from functools import partial
from itertools import (filterfalse,
                       chain)
from types import (ModuleType,
                   FunctionType)
from typing import (Any,
                    Optional,
                    Type,
                    Callable,
                    Iterable,
                    Iterator,
                    Mapping,
                    Tuple,
                    List)

import autopep8
import click
from pathspec import (PathSpec,
                      patterns)

from liable import (modules,
                    namespaces,
                    annotations)
from liable.arboterum import (ImportType,
                              split_imports,
                              is_import_statement,
                              to_tree)
from liable.utils import (find_files,
                          join_strings,
                          is_python_module)
from liable.paths import (to_relative_path,
                          to_import_path)
from liable.validators import (validate_paths,
                               validate_modules_paths,
                               validate_modules)


@click.group()
def main() -> None:
    return


@main.command(name='modules')
@click.option('--recursive', '-r',
              is_flag=True,
              help='Recursively walks through given directory.')
@click.option('--ignore-patterns-path', '-i',
              help='Path to file with patterns of paths names to ignore '
                   '(based on ".gitignore" syntax, '
                   'more at https://git-scm.com/docs/gitignore).')
@click.argument('paths',
                nargs=-1)
def search_modules(recursive: bool,
                   ignore_patterns_path: str,
                   paths: str) -> None:
    """Searches Python modules in paths."""
    if not paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    paths = list(map(os.path.abspath, paths))

    try:
        validate_paths(paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    files_paths = chain.from_iterable(map(partial(find_files,
                                                  recursive=recursive),
                                          paths))
    modules_paths = filter(is_python_module, files_paths)

    if ignore_patterns_path:
        with open(ignore_patterns_path) as ignore_patterns_file:
            path_spec = PathSpec.from_lines(patterns.GitWildMatchPattern,
                                            ignore_patterns_file)
        modules_paths = list(modules_paths)
        ignored_paths = list(path_spec.match_files(modules_paths))
        modules_paths = filterfalse(partial(operator.contains,
                                            ignored_paths),
                                    modules_paths)

    for module_path in modules_paths:
        click.echo(module_path)


TEST_CASE_PARAMETER_TEMPLATE = '{parameter}: {annotation}'
TEST_CASE_DEFINITION_TEMPLATE = 'def test_{function}({parameters}) -> None:\n'
RESULT_NAME = 'result'
FUNCTION_ARGUMENTS_TEMPLATES = {
    inspect._POSITIONAL_ONLY: '{argument}',
    inspect._POSITIONAL_OR_KEYWORD: '{argument}',
    inspect._VAR_POSITIONAL: '*{argument}',
    inspect._KEYWORD_ONLY: '{parameter}={argument}',
    inspect._VAR_KEYWORD: '**{argument}'
}
FUNCTION_CALL_TEMPLATE = '{result} = {function}({arguments})\n\n'
RETURN_TYPE_CHECK_TEMPLATE = 'isinstance({result}, {return_type})'
NONE_RETURN_TYPE_CHECK_TEMPLATE = '{result} is None'
ASSERTION_TEMPLATE = 'assert {statement}\n'


@main.command(name='tests')
@click.option('--spaces-count', '-s',
              type=click.IntRange(1),
              default=4,
              help='Number of spaces used for indentation.')
@click.argument('modules_paths',
                nargs=-1)
def generate_tests(spaces_count: int,
                   modules_paths: List[str]) -> None:
    """Generates test cases skeletons for modules."""
    if not modules_paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    modules_paths = list(map(os.path.abspath, modules_paths))

    try:
        validate_paths(modules_paths)
        validate_modules_paths(modules_paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    built_ins = modules.to_dict(__builtins__)
    for module_path in modules_paths:
        try:
            test_cases = generate_module_test_cases(module_path,
                                                    built_ins=built_ins,
                                                    spaces_count=spaces_count)
        except ImportError as err:
            raise click.BadParameter(err) from err

        click.echo(test_cases)


def generate_module_test_cases(module_path: str,
                               *,
                               built_ins: namespaces.NamespaceType,
                               spaces_count: int) -> str:
    module = modules.path_to_skeleton(module_path)
    modules.load(module)

    module_dict = modules.to_dict(module)
    module_dict.update(built_ins)

    if collections not in module_dict.values():
        module_dict[collections.__name__] = collections
    if Any not in module_dict.values():
        module_dict['Any'] = Any
    if Optional not in module_dict.values():
        module_dict['Optional'] = Optional

    dependent_objects = dependent_objects_namespace(module_path)
    dependent_objects.update(built_ins)

    module_objects = {name: content
                      for name, content in module_dict.items()
                      if name not in dependent_objects}
    module_functions = {name: content
                        for name, content in module_objects.items()
                        if inspect.isfunction(content)}

    def to_name(annotation: Type) -> str:
        annotation = annotations.normalize(annotation)
        return annotation.to_string(module_dict)

    tab = ' ' * spaces_count
    test_case_generator = partial(generate_test_case,
                                  tab=tab,
                                  to_name_converter=to_name)
    test_cases = map(test_case_generator, module_functions.values())
    return autopep8.fix_code(''.join(test_cases),
                             options={'aggressive': True,
                                      'max_line_length': 79})


def dependent_objects_namespace(module_path: str) -> namespaces.NamespaceType:
    with open(module_path) as source_file:
        source = source_file.read()
    tree = to_tree(source,
                   file_name=module_path)
    imports = filter(is_import_statement, tree.body)

    module_directory_path = os.path.dirname(module_path)
    module_directory_relative_path = to_relative_path(module_directory_path)

    def relative_import_to_absolute(statement: ImportType) -> ImportType:
        if isinstance(statement, ast.Import):
            return statement
        else:
            module = to_package(statement)
            return ast.ImportFrom(module=module,
                                  level=0,
                                  names=statement.names,
                                  lineno=statement.lineno,
                                  col_offset=statement.col_offset)

    def to_package(statement: ast.ImportFrom) -> str:
        module = statement.module or ''
        if is_import_relative(statement):
            jumps = (os.pardir + os.sep) * (statement.level - 1)
            module_path = os.path.join(module_directory_relative_path,
                                       jumps, module)
            module_path = os.path.normpath(module_path)
            module = to_import_path(module_path)
        return module

    def is_import_relative(statement: ast.ImportFrom) -> bool:
        return statement.level > 0

    imports = map(relative_import_to_absolute, imports)
    return dict(load_dependent_objects(imports))


def generate_test_case(function: FunctionType,
                       *,
                       tab: str,
                       to_name_converter: Callable[[Type], str]) -> str:
    signature = inspect.signature(function)
    function_parameters = signature.parameters.values()
    test_parameters_str = join_strings(
            TEST_CASE_PARAMETER_TEMPLATE.format(
                    parameter=parameter.name,
                    annotation=to_name_converter(parameter.annotation)
            )
            for parameter in function_parameters)
    function_arguments_str = join_strings(
            FUNCTION_ARGUMENTS_TEMPLATES[parameter.kind].format(
                    parameter=parameter.name,
                    argument=parameter.name)
            for parameter in function_parameters)
    return_annotation = signature.return_annotation
    return_annotation_bases = to_bases(return_annotation)

    def to_statement(annotation_base: Type) -> str:
        if annotation_base is None:
            return NONE_RETURN_TYPE_CHECK_TEMPLATE
        else:
            return RETURN_TYPE_CHECK_TEMPLATE

    statements = sorted(set(map(to_statement, return_annotation_bases)))
    if len(statements) == 1:
        statement, = statements
        assertion_template = ASSERTION_TEMPLATE.format(statement=statement)
    else:
        statement = '(' + '\nor\n'.join(statements) + ')'
        assertion_template = ASSERTION_TEMPLATE.format(statement=statement)

    return_type = None
    defined_return_annotation_bases = list(filter(None,
                                                  return_annotation_bases))
    if defined_return_annotation_bases:
        if len(defined_return_annotation_bases) == 1:
            return_annotation_base, = defined_return_annotation_bases
            return_type = to_name_converter(return_annotation_base)
        else:
            return_types = list(map(to_name_converter,
                                    defined_return_annotation_bases))
            return_types_str = ', '.join(return_types)
            return_type = ('({return_types})'
                           .format(return_types=return_types_str))

    test_case_template = (TEST_CASE_DEFINITION_TEMPLATE
                          + tab + FUNCTION_CALL_TEMPLATE
                          + tab + assertion_template)
    return test_case_template.format(function=function.__name__,
                                     parameters=test_parameters_str,
                                     result=RESULT_NAME,
                                     arguments=function_arguments_str,
                                     return_type=return_type)


def load_dependent_objects(imports: Iterable[ImportType]
                           ) -> Iterator[Tuple[str, Any]]:
    dependent_objects_names = dict(chain.from_iterable(map(split_imports,
                                                           imports)))
    dependencies_names = set(dependent_objects_names.values())
    validate_modules(dependencies_names)
    dependencies_skeletons = map(modules.name_to_skeleton, dependencies_names)
    dependencies = dict(zip(dependencies_names, dependencies_skeletons))
    for module_name, module in dependencies.items():
        loaded_module = sys.modules.get(module_name, None)
        if loaded_module is None:
            modules.load(module)
        else:
            dependencies[module_name] = loaded_module
    yield from juxtapose_objects(dependent_objects_names,
                                 dependencies)


def juxtapose_objects(objects_by_modules_names: Mapping[str, str],
                      modules_by_names: Mapping[str, ModuleType]
                      ) -> Iterator[Tuple[str, Any]]:
    for object_name, module_name in objects_by_modules_names.items():
        module = modules_by_names[module_name]
        try:
            object_ = getattr(module, object_name)
        except AttributeError as err:
            if not module_name.endswith(object_name):
                raise err
            object_ = module
        yield object_name, object_


def to_bases(annotation: Type) -> Tuple[Type, ...]:
    if not isinstance(annotation, annotations.Annotation):
        annotation = annotations.normalize(annotation)
    return annotation.bases


if __name__ == '__main__':
    main()
