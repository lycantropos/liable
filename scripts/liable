#!/usr/bin/env python3
import ast
import collections
import inspect
import operator
import os
from functools import partial
from itertools import (filterfalse,
                       chain)
from types import (ModuleType,
                   FunctionType)
from typing import (Any,
                    Optional,
                    Type,
                    Callable,
                    Iterable,
                    Iterator,
                    Mapping,
                    Tuple,
                    List)

import autopep8
import click
from pathspec import (PathSpec,
                      patterns)

from liable import (modules,
                    namespaces,
                    annotator,
                    arboretum,
                    catalog,
                    files)
from liable.strings import (join_strings,
                            join_with_wrapping)
from liable.utils import is_python_module
from liable.validators import (validate_paths,
                               validate_modules_paths,
                               validate_modules)


@click.group()
def main() -> None:
    return


@main.command(name='modules')
@click.option('--recursive', '-r',
              is_flag=True,
              help='Recursively walks through given directory.')
@click.option('--ignore-patterns-path', '-i',
              help='Path to file with patterns of paths names to ignore '
                   '(based on ".gitignore" syntax, '
                   'more at https://git-scm.com/docs/gitignore).')
@click.argument('paths',
                nargs=-1)
def search_modules(recursive: bool,
                   ignore_patterns_path: str,
                   paths: str) -> None:
    """Searches Python modules in paths."""
    if not paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    paths = list(map(os.path.abspath, paths))

    try:
        validate_paths(paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    files_seeker = partial(files.find,
                           recursive=recursive)
    files_paths = chain.from_iterable(map(files_seeker, paths))
    modules_paths = filter(is_python_module, files_paths)

    if ignore_patterns_path:
        with open(ignore_patterns_path) as ignore_patterns_file:
            path_spec = PathSpec.from_lines(patterns.GitWildMatchPattern,
                                            ignore_patterns_file)
        modules_paths = list(modules_paths)
        ignored_paths = list(path_spec.match_files(modules_paths))
        modules_paths = filterfalse(partial(operator.contains,
                                            ignored_paths),
                                    modules_paths)

    for module_path in modules_paths:
        click.echo(module_path)


CoderType = Callable[[FunctionType, str, namespaces.NamespaceType], str]

TEST_CASE_PARAMETER_TEMPLATE = '{parameter}: {annotation}'
TEST_CASE_DEFINITION_TEMPLATE = 'def test_{function}({parameters}) -> None:\n'
RESULT_NAME = 'result'
FUNCTION_ARGUMENTS_TEMPLATES = {
    inspect._POSITIONAL_ONLY: '{argument}',
    inspect._POSITIONAL_OR_KEYWORD: '{argument}',
    inspect._VAR_POSITIONAL: '*{argument}',
    inspect._KEYWORD_ONLY: '{parameter}={argument}',
    inspect._VAR_KEYWORD: '**{argument}'
}
FUNCTION_CALL_TEMPLATE = '{result} = {function}({arguments})\n\n'
RETURN_TYPE_CHECK_TEMPLATE = 'isinstance({result}, {return_type})'
NONE_RETURN_TYPE_CHECK_TEMPLATE = '{result} is None'
ASSERTION_TEMPLATE = 'assert {statement}\n'


@main.command(name='tests')
@click.option('--spaces-count', '-s',
              type=click.IntRange(1),
              default=4,
              help='Number of spaces used for indentation.')
@click.argument('modules_paths',
                nargs=-1)
def generate_tests(spaces_count: int,
                   modules_paths: List[str]) -> None:
    """Generates test cases skeletons for modules."""
    if not modules_paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    modules_paths = list(map(os.path.abspath, modules_paths))

    try:
        validate_paths(modules_paths)
        validate_modules_paths(modules_paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    built_ins = namespaces.from_module(__builtins__)
    test_cases_generator = partial(generate_module_tests_code,
                                   built_ins=built_ins,
                                   spaces_count=spaces_count,
                                   coder=generate_test_case)
    for module_path in modules_paths:
        try:
            test_cases = test_cases_generator(module_path)
        except ImportError as err:
            raise click.BadParameter(err) from err

        click.echo(test_cases)


def generate_module_tests_code(module_path: str,
                               *,

                               built_ins: namespaces.NamespaceType,
                               spaces_count: int,
                               coder: CoderType) -> str:
    module = modules.from_path(module_path)

    namespace = namespaces.from_module(module)
    namespace.update(built_ins)

    if collections not in namespace.values():
        namespace[collections.__name__] = collections
    if Any not in namespace.values():
        namespace['Any'] = Any
    if Optional not in namespace.values():
        namespace['Optional'] = Optional

    module_objects = [content
                      for content in namespace.values()
                      if is_object_from_module(content, module)]
    module_functions = [object_
                        for object_ in module_objects
                        if inspect.isfunction(object_)]


    tab = ' ' * spaces_count
    coder = partial(coder,
                    tab=tab,
                    namespace=namespace)
    code_blocks = map(coder, module_functions)
    return autopep8.fix_code(''.join(code_blocks),
                             options={'aggressive': True,
                                      'max_line_length': 79})


def is_object_from_module(object_: Any,
                          module: ModuleType) -> bool:
    return inspect.getmodule(object_) is module


def generate_test_case(function: FunctionType,
                       *,
                       tab: str,
                       namespace: namespaces.NamespaceType) -> str:
    signature = inspect.signature(function)
    function_parameters = signature.parameters.values()

    def to_name(annotation: Type) -> str:
        annotation = annotator.normalize(annotation)
        return annotation.to_string(namespace)

    test_parameters_str = join_strings(
            TEST_CASE_PARAMETER_TEMPLATE.format(
                    parameter=parameter.name,
                    annotation=to_name(parameter.annotation)
            )
            for parameter in function_parameters)
    function_arguments_str = join_strings(
            FUNCTION_ARGUMENTS_TEMPLATES[parameter.kind].format(
                    parameter=parameter.name,
                    argument=parameter.name)
            for parameter in function_parameters)
    return_annotation = signature.return_annotation
    return_annotation_bases = to_bases(return_annotation)

    def to_statement(annotation_base: Type) -> str:
        if annotation_base is None:
            return NONE_RETURN_TYPE_CHECK_TEMPLATE
        else:
            return RETURN_TYPE_CHECK_TEMPLATE

    statements = sorted(set(map(to_statement, return_annotation_bases)))
    statement = join_with_wrapping(statements,
                                   sep='\nor\n')
    assertion_template = ASSERTION_TEMPLATE.format(statement=statement)

    return_type = None
    defined_return_annotation_bases = list(filter(None,
                                                  return_annotation_bases))
    if defined_return_annotation_bases:
        if len(defined_return_annotation_bases) == 1:
            return_annotation_base, = defined_return_annotation_bases
            return_type = to_name(return_annotation_base)
        else:
            return_types = list(map(to_name,
                                    defined_return_annotation_bases))
            return_types_str = ', '.join(return_types)
            return_type = ('({return_types})'
                           .format(return_types=return_types_str))

    test_case_template = (TEST_CASE_DEFINITION_TEMPLATE
                          + tab + FUNCTION_CALL_TEMPLATE
                          + tab + assertion_template)
    return test_case_template.format(function=function.__name__,
                                     parameters=test_parameters_str,
                                     result=RESULT_NAME,
                                     arguments=function_arguments_str,
                                     return_type=return_type)


def to_bases(annotation: Type) -> Tuple[Type, ...]:
    if not isinstance(annotation, annotator.Annotation):
        annotation = annotator.normalize(annotation)
    return annotation.bases


if __name__ == '__main__':
    main()
