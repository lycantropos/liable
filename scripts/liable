#!/usr/bin/env python3
import collections
import inspect
import operator
import os
from collections import defaultdict
from functools import partial
from itertools import (filterfalse,
                       chain)
from types import FunctionType
from typing import (Any,
                    Optional,
                    Type,
                    Iterator,
                    Iterable,
                    Dict,
                    Tuple,
                    List)

import autopep8
import click
from pathspec import (PathSpec,
                      patterns)

from liable import (modules,
                    namespaces,
                    annotator,
                    files,
                    catalog,
                    functions,
                    strings)
from liable.utils import (is_python_module,
                          merge_mappings)
from liable.validators import (validate_paths,
                               validate_modules_paths)


@click.group()
def main() -> None:
    return


@main.command(name='modules')
@click.option('--recursive', '-r',
              is_flag=True,
              help='Recursively walks through given directory.')
@click.option('--ignore-patterns-path', '-i',
              help='Path to file with patterns of paths names to ignore '
                   '(based on ".gitignore" syntax, '
                   'more at https://git-scm.com/docs/gitignore).')
@click.argument('paths',
                nargs=-1)
def search_modules(recursive: bool,
                   ignore_patterns_path: str,
                   paths: List[str]) -> None:
    """Searches Python modules in paths."""
    if not paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    paths = list(map(os.path.abspath, paths))

    try:
        validate_paths(paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    files_seeker = partial(files.find,
                           recursive=recursive)
    files_paths = chain.from_iterable(map(files_seeker, paths))
    modules_paths = filter(is_python_module, files_paths)

    if ignore_patterns_path:
        with open(ignore_patterns_path) as ignore_patterns_file:
            path_spec = PathSpec.from_lines(patterns.GitWildMatchPattern,
                                            ignore_patterns_file)
        modules_paths = list(modules_paths)
        ignored_paths = list(path_spec.match_files(modules_paths))
        modules_paths = filterfalse(partial(operator.contains,
                                            ignored_paths),
                                    modules_paths)

    for module_path in modules_paths:
        click.echo(module_path)


TEST_CASE_PARAMETER_TEMPLATE = '{parameter}: {annotation}'
TEST_CASE_DEFINITION_TEMPLATE = 'def test_{function}({parameters}) -> None:\n'
RESULT_NAME = 'result'
FUNCTION_ARGUMENTS_TEMPLATES = {
    inspect._POSITIONAL_ONLY: '{argument}',
    inspect._POSITIONAL_OR_KEYWORD: '{argument}',
    inspect._VAR_POSITIONAL: '*{argument}',
    inspect._KEYWORD_ONLY: '{parameter}={argument}',
    inspect._VAR_KEYWORD: '**{argument}'
}
FUNCTION_CALL_TEMPLATE = '{result} = {function}({arguments})\n\n'
RETURN_TYPE_CHECK_TEMPLATE = 'isinstance({result}, {return_type})'
NONE_RETURN_TYPE_CHECK_TEMPLATE = '{result} is None'
ASSERTION_TEMPLATE = 'assert {statement}\n'

utilities = {catalog.ObjectPath(module=collections.__name__,
                                object=None,
                                type=catalog.PathType.absolute): collections,
             catalog.ObjectPath(module=Any.__module__,
                                object='Any',
                                type=catalog.PathType.relative): Any,
             catalog.ObjectPath(module=Optional.__module__,
                                object='Optional',
                                type=catalog.PathType.relative): Optional}


@main.command(name='tests')
@click.option('--spaces-count', '-s',
              type=click.IntRange(1),
              default=4,
              help='Number of spaces used for indentation.')
@click.argument('modules_paths',
                nargs=-1)
def generate_tests(spaces_count: int,
                   modules_paths: List[str]) -> None:
    """Generates test cases skeletons for modules."""
    if not modules_paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    modules_paths = list(map(os.path.abspath, modules_paths))

    try:
        validate_paths(modules_paths)
        validate_modules_paths(modules_paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    built_ins = namespaces.built_ins()
    add_utilities = partial(merge_mappings, utilities)
    modules_namespaces = map(namespaces.from_module,
                             map(modules.from_path, modules_paths))
    modules_namespaces = map(add_utilities, modules_namespaces)
    test_cases_generator = partial(generate_test_cases,
                                   built_ins=built_ins,
                                   spaces_count=spaces_count)

    for namespace in modules_namespaces:
        module_objects = [content
                          for path, content in namespace.items()
                          if path.type == catalog.PathType.inner]
        module_functions = list(filter(inspect.isfunction, module_objects))
        try:
            test_cases = test_cases_generator(module_functions,
                                              namespace=namespace)
        except ImportError as err:
            raise click.BadParameter(err) from err

        click.echo(test_cases)


def generate_test_cases(module_functions: Iterable[FunctionType],
                        *,
                        built_ins: namespaces.NamespaceType,
                        namespace: namespaces.NamespaceType,
                        spaces_count: int) -> str:
    dependants_paths = functions.dependants_paths(module_functions,
                                                  built_ins=built_ins,
                                                  namespace=namespace,
                                                  generic_return_type=False)
    dependants_paths = objects_paths_by_modules_names(dependants_paths)
    imports = to_imports(dependants_paths)
    tab = ' ' * spaces_count
    test_case_factory = partial(generate_test_case,
                                tab=tab,
                                built_ins=built_ins,
                                namespace=namespace)
    tests_cases = map(test_case_factory, module_functions)
    code_blocks = chain(imports, tests_cases)
    return autopep8.fix_code(''.join(code_blocks),
                             options={'aggressive': True,
                                      'max_line_length': 79})


def to_imports(dependants_paths: Dict[str, List[catalog.ObjectPath]]
               ) -> Iterator[str]:
    def is_absolute(object_path: catalog.ObjectPath) -> bool:
        return object_path.type == catalog.PathType.absolute

    for module_name, paths in dependants_paths.items():
        non_absolute_paths = list(filterfalse(is_absolute, paths))
        if non_absolute_paths:
            objects_names = list(map(operator.attrgetter('object'),
                                     non_absolute_paths))
            objects_names_str = strings.join_with_wrapping(objects_names)
            yield ('from {module} import {objects}\n'
                   .format(module=module_name,
                           objects=objects_names_str))
        absolute_path = next(filter(is_absolute, paths), None)
        if absolute_path is not None:
            yield 'import {module}\n'.format(module=module_name)


def objects_paths_by_modules_names(objects_paths: Iterable[catalog.ObjectPath]
                                   ) -> Dict[str, List[catalog.ObjectPath]]:
    result = defaultdict(list)
    for object_path in objects_paths:
        result[object_path.module].append(object_path)
    return result


def generate_test_case(function: FunctionType,
                       *,
                       tab: str,
                       built_ins: namespaces.NamespaceType,
                       namespace: namespaces.NamespaceType) -> str:
    namespace = merge_mappings(built_ins, namespace)

    def to_name(annotation: Type) -> str:
        annotation = annotator.normalize(annotation)
        return annotation.to_string(namespace)

    signature = inspect.signature(function)
    function_parameters = signature.parameters.values()
    test_parameters_str = strings.join(
            TEST_CASE_PARAMETER_TEMPLATE.format(
                    parameter=parameter.name,
                    annotation=to_name(parameter.annotation)
            )
            for parameter in function_parameters)
    function_arguments_str = strings.join(
            FUNCTION_ARGUMENTS_TEMPLATES[parameter.kind].format(
                    parameter=parameter.name,
                    argument=parameter.name)
            for parameter in function_parameters)
    return_annotation = signature.return_annotation
    return_annotation_bases = to_bases(return_annotation)

    def to_statement(annotation_base: Type) -> str:
        if annotation_base is None:
            return NONE_RETURN_TYPE_CHECK_TEMPLATE
        else:
            return RETURN_TYPE_CHECK_TEMPLATE

    statements = sorted(set(map(to_statement, return_annotation_bases)))
    statement = strings.join_with_wrapping(statements,
                                           sep='\nor\n')
    assertion_template = ASSERTION_TEMPLATE.format(statement=statement)

    return_type = None
    defined_return_annotation_bases = list(filter(None,
                                                  return_annotation_bases))
    if defined_return_annotation_bases:
        if len(defined_return_annotation_bases) == 1:
            return_annotation_base, = defined_return_annotation_bases
            return_type = to_name(return_annotation_base)
        else:
            return_types = list(map(to_name,
                                    defined_return_annotation_bases))
            return_types_str = ', '.join(return_types)
            return_type = ('({return_types})'
                           .format(return_types=return_types_str))

    test_case_template = (TEST_CASE_DEFINITION_TEMPLATE
                          + tab + FUNCTION_CALL_TEMPLATE
                          + tab + assertion_template)
    return test_case_template.format(function=function.__name__,
                                     parameters=test_parameters_str,
                                     result=RESULT_NAME,
                                     arguments=function_arguments_str,
                                     return_type=return_type)


def to_bases(annotation: Type) -> Tuple[Type, ...]:
    if not isinstance(annotation, annotator.Annotation):
        annotation = annotator.normalize(annotation)
    return annotation.bases


if __name__ == '__main__':
    main()
