#!/usr/bin/env python3
import collections
import operator
import os
from functools import partial
from itertools import (filterfalse,
                       chain)
from typing import (Any,
                    Optional,
                    List)

import click
from pathspec import (PathSpec,
                      patterns)

from liable import (modules,
                    namespaces,
                    file_system,
                    catalog,
                    test_cases)
from liable.utils import (is_python_module,
                          merge_mappings)
from liable.validators import (validate_paths,
                               validate_modules_paths)


@click.group()
def main() -> None:
    return


@main.command(name='modules')
@click.option('--recursive', '-r',
              is_flag=True,
              help='Recursively walks through given directory.')
@click.option('--ignore-patterns-path', '-i',
              help='Path to file with patterns of paths names to ignore '
                   '(based on ".gitignore" syntax, '
                   'more at https://git-scm.com/docs/gitignore).')
@click.argument('paths',
                nargs=-1)
def search_modules(recursive: bool,
                   ignore_patterns_path: str,
                   paths: List[str]) -> None:
    """Searches Python modules in paths."""
    if not paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    paths = list(map(os.path.abspath, paths))

    try:
        validate_paths(paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    files_paths_seeker = partial(file_system.find_files,
                                 recursive=recursive)
    files_paths = chain.from_iterable(map(files_paths_seeker, paths))
    modules_paths = filter(is_python_module, files_paths)

    if ignore_patterns_path:
        with open(ignore_patterns_path) as ignore_patterns_file:
            path_spec = PathSpec.from_lines(patterns.GitWildMatchPattern,
                                            ignore_patterns_file)
        modules_paths = list(modules_paths)
        ignored_paths = list(path_spec.match_files(modules_paths))
        modules_paths = filterfalse(partial(operator.contains,
                                            ignored_paths),
                                    modules_paths)

    for module_path in modules_paths:
        click.echo(module_path)


utilities = {catalog.ObjectPath(module=collections.__name__,
                                object=None,
                                type=catalog.PathType.absolute): collections,
             catalog.ObjectPath(module=Any.__module__,
                                object='Any',
                                type=catalog.PathType.relative): Any,
             catalog.ObjectPath(module=Optional.__module__,
                                object='Optional',
                                type=catalog.PathType.relative): Optional}


@main.command(name='tests')
@click.option('--parent-directory', '-p',
              type=click.Path(exists=True),
              default=None,
              help='Modules top-level directory.')
@click.option('--target-directory', '-t',
              type=click.Path(exists=True),
              default=None,
              help='Target directory.')
@click.option('--spaces-count', '-s',
              type=click.IntRange(1),
              default=4,
              help='Number of spaces used for indentation.')
@click.argument('modules_paths',
                nargs=-1)
def generate_tests(parent_directory: Optional[str],
                   target_directory: Optional[str],
                   spaces_count: int,
                   modules_paths: List[str]) -> None:
    """Generates test cases skeletons for modules."""
    if not modules_paths:
        err_msg = 'No paths specified.'
        raise click.BadParameter(err_msg)

    modules_paths = list(map(os.path.abspath, modules_paths))

    if parent_directory is None:
        parent_directory = os.path.commonpath(modules_paths)

    try:
        validate_paths(modules_paths)
        validate_modules_paths(modules_paths)
    except OSError as err:
        raise click.BadParameter(err) from err

    built_ins = namespaces.built_ins()
    add_utilities = partial(merge_mappings, utilities)
    modules_namespaces = map(namespaces.from_module,
                             map(modules.from_path, modules_paths))
    modules_namespaces = dict(zip(modules_paths,
                                  map(add_utilities, modules_namespaces)))
    test_cases_generator = partial(test_cases.from_functions,
                                   built_ins=built_ins,
                                   spaces_count=spaces_count)
    for module_path, module_namespace in modules_namespaces.items():
        module_functions = list(namespaces.inner_functions(module_namespace))
        try:
            source = test_cases_generator(module_functions,
                                          namespace=module_namespace)
        except ImportError as err:
            raise click.BadParameter(err) from err
        click.echo(source)


def write_source(source: str,
                 *,
                 top_directory: str,
                 module_full_name: str) -> None:
    *sub_directories, module_name = module_full_name.split(catalog.SEPARATOR)
    file_system.make_packages(top_directory, *sub_directories)
    module_directory = os.path.join(top_directory,
                                    *sub_directories)
    os.makedirs(module_directory,
                exist_ok=True)
    module_path = os.path.join(module_directory,
                               module_name + '.py')
    with open(module_path, mode='w') as module_file:
        module_file.write(source)


if __name__ == '__main__':
    main()
